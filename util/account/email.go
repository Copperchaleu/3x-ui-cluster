package account

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// ClientEmailInfo contains parsed information from a client email
type ClientEmailInfo struct {
	Username   string
	SlaveId    int
	InboundId  int
	AccountId  int
	ShortHash  string
	IsGenerated bool // Whether this email was auto-generated by the system
}

// GenerateClientEmail generates a unique client email in the format:
// {accountUsername}-s{slaveId}-i{inboundId}-{shortHash}
// Example: alice-s2-i3-a7f2
func GenerateClientEmail(username string, slaveId, inboundId, accountId int) string {
	// Generate deterministic short hash from IDs
	raw := fmt.Sprintf("%d-%d-%d", accountId, slaveId, inboundId)
	hash := md5.Sum([]byte(raw))
	shortHash := hex.EncodeToString(hash[:])[:4]

	return fmt.Sprintf("%s-s%d-i%d-%s", username, slaveId, inboundId, shortHash)
}

// ParseClientEmail parses an auto-generated client email back into its components.
// Returns nil if the email is not in the expected format (e.g., manually created).
func ParseClientEmail(email string) *ClientEmailInfo {
	// Pattern: anything-s{digits}-i{digits}-{4chars}
	// We parse from right to left to support usernames with hyphens
	parts := strings.Split(email, "-")
	
	if len(parts) < 4 {
		return nil // Not enough parts
	}

	info := &ClientEmailInfo{
		IsGenerated: false,
	}

	// Parse from right to left
	shortHash := parts[len(parts)-1]
	inboundPart := parts[len(parts)-2]
	slavePart := parts[len(parts)-3]
	usernameParts := parts[:len(parts)-3]

	// Validate short hash (4 hex characters)
	if len(shortHash) != 4 {
		return nil
	}
	if matched, _ := regexp.MatchString("^[a-f0-9]{4}$", shortHash); !matched {
		return nil
	}

	// Parse inbound ID (format: i{digits})
	if !strings.HasPrefix(inboundPart, "i") {
		return nil
	}
	inboundId, err := strconv.Atoi(inboundPart[1:])
	if err != nil {
		return nil
	}

	// Parse slave ID (format: s{digits})
	if !strings.HasPrefix(slavePart, "s") {
		return nil
	}
	slaveId, err := strconv.Atoi(slavePart[1:])
	if err != nil {
		return nil
	}

	// Reconstruct username (everything before slave ID part)
	username := strings.Join(usernameParts, "-")
	if username == "" {
		return nil
	}

	info.Username = username
	info.SlaveId = slaveId
	info.InboundId = inboundId
	info.ShortHash = shortHash
	info.IsGenerated = true

	return info
}

// ValidateClientEmail validates if an email is in the correct format.
// It accepts both auto-generated emails and custom emails.
func ValidateClientEmail(email string) bool {
	if email == "" {
		return false
	}

	// Basic email character validation (RFC 5321 local part)
	// Allow alphanumeric, dots, hyphens, underscores
	matched, _ := regexp.MatchString(`^[a-zA-Z0-9._-]+$`, email)
	return matched
}

// VerifyGeneratedEmail verifies if a generated email matches the expected hash.
// This ensures the email was generated correctly and hasn't been tampered with.
func VerifyGeneratedEmail(email string, accountId int) bool {
	info := ParseClientEmail(email)
	if info == nil {
		return false
	}

	// Regenerate email with the parsed info and account ID
	expectedEmail := GenerateClientEmail(info.Username, info.SlaveId, info.InboundId, accountId)
	return expectedEmail == email
}
